{"ast":null,"code":"/**\n * Copyright 2017 Intel Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ------------------------------------------------------------------------------\n */\n'use strict';\n\nconst {\n  NoSuchAlgorithmError,\n  SigningError,\n  ParseError\n} = require('./core');\n\nconst secp256k1 = require('./secp256k1');\n/**\n * A convenient wrapper of Context and PrivateKey\n */\n\n\nclass Signer {\n  /**\n   * Constructs a new Signer\n   *\n   * @param {Context} context - a cryptographic context\n   * @param {PrivateKey} privateKey - private key\n   */\n  constructor(context, privateKey) {\n    this._context = context;\n    this._privateKey = privateKey;\n    this._publicKey = null;\n  }\n  /**\n   * Signs the given message.\n   *\n   * @param {Buffer} message - the message bytes\n   * @return {string} - the signature in a hex-encoded string\n   * @throws {SigningError} - if any error occurs during the signing process\n   */\n\n\n  sign(message) {\n    return this._context.sign(message, this._privateKey);\n  }\n  /**\n   * Return the public key for this Signer instance.\n   *\n   * @return {PublicKey} the public key instance\n   */\n\n\n  getPublicKey() {\n    if (this._publicKey === null) {\n      this._publicKey = this._context.getPublicKey(this._privateKey);\n    }\n\n    return this._publicKey;\n  }\n\n}\n/**\n * Factory for generating signers.\n */\n\n\nclass CryptoFactory {\n  /**\n   * Constructs a CryptoFactory.\n   *\n   * @param {Context} context - a cryptographic context\n   */\n  constructor(context) {\n    this._context = context;\n  }\n  /**\n   * Returns the context associated with this factory\n   *\n   * @return {Context}\n   */\n\n\n  getContext() {\n    return this._context;\n  }\n  /**\n   * Create a new signer for the given private key.\n   *\n   * @param {PrivateKey} privateKey - a private key\n   * @return {Signer} - a signer instance\n   */\n\n\n  newSigner(privateKey) {\n    return new Signer(this._context, privateKey);\n  }\n\n}\n/**\n * Returns an Context instance by algorithm name.\n *\n * @param {string} algorithmName - the algorithm name\n * @return {Context} a context instance for the given algorithm\n * @throws {NoSuchAlgorithmError} if the algorithm is unknown\n */\n\n\nconst createContext = algorithmName => {\n  if (algorithmName === 'secp256k1') {\n    return new secp256k1.Secp256k1Context();\n  } else {\n    throw new NoSuchAlgorithmError(`No such algorithm: ${algorithmName}`);\n  }\n};\n\nmodule.exports = {\n  // Re-export the errors\n  NoSuchAlgorithmError,\n  SigningError,\n  ParseError,\n  Signer,\n  CryptoFactory,\n  createContext\n};","map":{"version":3,"sources":["/home/amirhossein/AMHF/blockchain/blockchain98/app/node_modules/sawtooth-sdk/signing/index.js"],"names":["NoSuchAlgorithmError","SigningError","ParseError","require","secp256k1","Signer","constructor","context","privateKey","_context","_privateKey","_publicKey","sign","message","getPublicKey","CryptoFactory","getContext","newSigner","createContext","algorithmName","Secp256k1Context","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA;;AAEA,MAAM;AAAEA,EAAAA,oBAAF;AAAwBC,EAAAA,YAAxB;AAAsCC,EAAAA;AAAtC,IAAqDC,OAAO,CAAC,QAAD,CAAlE;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAzB;AAEA;;;;;AAGA,MAAME,MAAN,CAAa;AACX;;;;;;AAMAC,EAAAA,WAAW,CAAEC,OAAF,EAAWC,UAAX,EAAuB;AAChC,SAAKC,QAAL,GAAgBF,OAAhB;AACA,SAAKG,WAAL,GAAmBF,UAAnB;AACA,SAAKG,UAAL,GAAkB,IAAlB;AACD;AAED;;;;;;;;;AAOAC,EAAAA,IAAI,CAAEC,OAAF,EAAW;AACb,WAAO,KAAKJ,QAAL,CAAcG,IAAd,CAAmBC,OAAnB,EAA4B,KAAKH,WAAjC,CAAP;AACD;AAED;;;;;;;AAKAI,EAAAA,YAAY,GAAI;AACd,QAAI,KAAKH,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,WAAKA,UAAL,GAAkB,KAAKF,QAAL,CAAcK,YAAd,CAA2B,KAAKJ,WAAhC,CAAlB;AACD;;AAED,WAAO,KAAKC,UAAZ;AACD;;AAnCU;AAsCb;;;;;AAGA,MAAMI,aAAN,CAAoB;AAClB;;;;;AAKAT,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpB,SAAKE,QAAL,GAAgBF,OAAhB;AACD;AAED;;;;;;;AAKAS,EAAAA,UAAU,GAAI;AACZ,WAAO,KAAKP,QAAZ;AACD;AAED;;;;;;;;AAMAQ,EAAAA,SAAS,CAAET,UAAF,EAAc;AACrB,WAAO,IAAIH,MAAJ,CAAW,KAAKI,QAAhB,EAA0BD,UAA1B,CAAP;AACD;;AA3BiB;AA8BpB;;;;;;;;;AAOA,MAAMU,aAAa,GAAGC,aAAa,IAAI;AACrC,MAAIA,aAAa,KAAK,WAAtB,EAAmC;AACjC,WAAO,IAAIf,SAAS,CAACgB,gBAAd,EAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAIpB,oBAAJ,CAA0B,sBAAqBmB,aAAc,EAA7D,CAAN;AACD;AACF,CAND;;AAQAE,MAAM,CAACC,OAAP,GAAiB;AACf;AACAtB,EAAAA,oBAFe;AAGfC,EAAAA,YAHe;AAIfC,EAAAA,UAJe;AAMfG,EAAAA,MANe;AAOfU,EAAAA,aAPe;AAQfG,EAAAA;AARe,CAAjB","sourcesContent":["/**\n * Copyright 2017 Intel Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ------------------------------------------------------------------------------\n */\n\n'use strict'\n\nconst { NoSuchAlgorithmError, SigningError, ParseError } = require('./core')\nconst secp256k1 = require('./secp256k1')\n\n/**\n * A convenient wrapper of Context and PrivateKey\n */\nclass Signer {\n  /**\n   * Constructs a new Signer\n   *\n   * @param {Context} context - a cryptographic context\n   * @param {PrivateKey} privateKey - private key\n   */\n  constructor (context, privateKey) {\n    this._context = context\n    this._privateKey = privateKey\n    this._publicKey = null\n  }\n\n  /**\n   * Signs the given message.\n   *\n   * @param {Buffer} message - the message bytes\n   * @return {string} - the signature in a hex-encoded string\n   * @throws {SigningError} - if any error occurs during the signing process\n   */\n  sign (message) {\n    return this._context.sign(message, this._privateKey)\n  }\n\n  /**\n   * Return the public key for this Signer instance.\n   *\n   * @return {PublicKey} the public key instance\n   */\n  getPublicKey () {\n    if (this._publicKey === null) {\n      this._publicKey = this._context.getPublicKey(this._privateKey)\n    }\n\n    return this._publicKey\n  }\n}\n\n/**\n * Factory for generating signers.\n */\nclass CryptoFactory {\n  /**\n   * Constructs a CryptoFactory.\n   *\n   * @param {Context} context - a cryptographic context\n   */\n  constructor (context) {\n    this._context = context\n  }\n\n  /**\n   * Returns the context associated with this factory\n   *\n   * @return {Context}\n   */\n  getContext () {\n    return this._context\n  }\n\n  /**\n   * Create a new signer for the given private key.\n   *\n   * @param {PrivateKey} privateKey - a private key\n   * @return {Signer} - a signer instance\n   */\n  newSigner (privateKey) {\n    return new Signer(this._context, privateKey)\n  }\n}\n\n/**\n * Returns an Context instance by algorithm name.\n *\n * @param {string} algorithmName - the algorithm name\n * @return {Context} a context instance for the given algorithm\n * @throws {NoSuchAlgorithmError} if the algorithm is unknown\n */\nconst createContext = algorithmName => {\n  if (algorithmName === 'secp256k1') {\n    return new secp256k1.Secp256k1Context()\n  } else {\n    throw new NoSuchAlgorithmError(`No such algorithm: ${algorithmName}`)\n  }\n}\n\nmodule.exports = {\n  // Re-export the errors\n  NoSuchAlgorithmError,\n  SigningError,\n  ParseError,\n\n  Signer,\n  CryptoFactory,\n  createContext\n}\n"]},"metadata":{},"sourceType":"script"}