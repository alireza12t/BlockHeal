{"ast":null,"code":"/**\n * Copyright 2017 Intel Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ------------------------------------------------------------------------------\n */\n'use strict';\n\nconst secp256k1 = require('secp256k1');\n\nconst {\n  createHash,\n  randomBytes\n} = require('crypto');\n\nconst {\n  PrivateKey,\n  PublicKey,\n  Context,\n  ParseError\n} = require('./core');\n\nclass Secp256k1PrivateKey extends PrivateKey {\n  /**\n   * @param {Buffer} privateKeyBytes - the bytes of the private key\n   */\n  constructor(privateKeyBytes) {\n    super();\n    this.privateKeyBytes = privateKeyBytes;\n  }\n\n  getAlgorithmName() {\n    return 'secp256k1';\n  }\n  /**\n   * @return {Buffer} the key in bytes\n   */\n\n\n  asBytes() {\n    return Buffer.from(this.privateKeyBytes);\n  }\n  /**\n   * Creates a private key from a hex encode set of bytes.\n   *\n   * @param {string} privateKeyHex - the key in hex\n   * @return {PrivateKey} a private key instance\n   * @throws {ParseError} if the private key is not valid\n   */\n\n\n  static fromHex(privateKeyHex) {\n    let buffer = Buffer.from(privateKeyHex, 'hex'); // verify that it is either a proper compressed or uncompressed key\n\n    if (!secp256k1.privateKeyVerify(buffer) && !secp256k1.privateKeyVerify(buffer, false)) {\n      throw new ParseError('Unable to parse a private key from the given hex');\n    }\n\n    return new Secp256k1PrivateKey(buffer);\n  }\n\n  static newRandom() {\n    let privKey;\n\n    do {\n      privKey = randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privKey));\n\n    return new Secp256k1PrivateKey(privKey);\n  }\n\n}\n\nclass Secp256k1PublicKey extends PublicKey {\n  constructor(publicKeyBytes) {\n    super();\n    this.publicKeyBytes = publicKeyBytes;\n  }\n\n  getAlgorithmName() {\n    return 'secp256k1';\n  }\n  /**\n   * @return {Buffer} the key in bytes\n   */\n\n\n  asBytes() {\n    return Buffer.from(this.publicKeyBytes);\n  }\n  /**\n   * Creates a public key from a hex encode set of bytes.\n   *\n   * @param {string} publicKeyHex - the key in hex\n   * @return {PublicKey} a public key instance\n   * @throws {ParseError} if the public key is not valid\n   */\n\n\n  static fromHex(publicKeyHex) {\n    let buffer = Buffer.from(publicKeyHex, 'hex');\n\n    if (!secp256k1.publicKeyVerify(buffer)) {\n      throw new ParseError('Unable to parse a private key from the given hex');\n    }\n\n    return new Secp256k1PublicKey(buffer);\n  }\n\n}\n\nclass Secp256k1Context extends Context {\n  getAlgorithmName() {\n    return 'secp256k1';\n  }\n\n  verify(signature, message, publicKey) {\n    const dataHash = createHash('sha256').update(message).digest();\n    const sigBytes = Buffer.from(signature, 'hex');\n    return secp256k1.verify(dataHash, sigBytes, publicKey.publicKeyBytes);\n  }\n\n  sign(message, privateKey) {\n    const dataHash = createHash('sha256').update(message).digest();\n    const result = secp256k1.sign(dataHash, privateKey.privateKeyBytes);\n    return result.signature.toString('hex');\n  }\n\n  getPublicKey(privateKey) {\n    return new Secp256k1PublicKey(secp256k1.publicKeyCreate(privateKey.privateKeyBytes));\n  }\n\n  newRandomPrivateKey() {\n    return Secp256k1PrivateKey.newRandom();\n  }\n\n}\n\nmodule.exports = {\n  Secp256k1PrivateKey,\n  Secp256k1PublicKey,\n  Secp256k1Context\n};","map":{"version":3,"sources":["/home/amirhossein/AMHF/blockchain/blockchain98/app/node_modules/sawtooth-sdk/signing/secp256k1.js"],"names":["secp256k1","require","createHash","randomBytes","PrivateKey","PublicKey","Context","ParseError","Secp256k1PrivateKey","constructor","privateKeyBytes","getAlgorithmName","asBytes","Buffer","from","fromHex","privateKeyHex","buffer","privateKeyVerify","newRandom","privKey","Secp256k1PublicKey","publicKeyBytes","publicKeyHex","publicKeyVerify","Secp256k1Context","verify","signature","message","publicKey","dataHash","update","digest","sigBytes","sign","privateKey","result","toString","getPublicKey","publicKeyCreate","newRandomPrivateKey","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Intel Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ------------------------------------------------------------------------------\n */\n\n'use strict'\n\nconst secp256k1 = require('secp256k1')\nconst { createHash, randomBytes } = require('crypto')\n\nconst { PrivateKey, PublicKey, Context, ParseError } = require('./core')\n\nclass Secp256k1PrivateKey extends PrivateKey {\n  /**\n   * @param {Buffer} privateKeyBytes - the bytes of the private key\n   */\n  constructor (privateKeyBytes) {\n    super()\n    this.privateKeyBytes = privateKeyBytes\n  }\n\n  getAlgorithmName () {\n    return 'secp256k1'\n  }\n\n  /**\n   * @return {Buffer} the key in bytes\n   */\n  asBytes () {\n    return Buffer.from(this.privateKeyBytes)\n  }\n\n  /**\n   * Creates a private key from a hex encode set of bytes.\n   *\n   * @param {string} privateKeyHex - the key in hex\n   * @return {PrivateKey} a private key instance\n   * @throws {ParseError} if the private key is not valid\n   */\n  static fromHex (privateKeyHex) {\n    let buffer = Buffer.from(privateKeyHex, 'hex')\n    // verify that it is either a proper compressed or uncompressed key\n    if (!secp256k1.privateKeyVerify(buffer) &&\n        !secp256k1.privateKeyVerify(buffer, false)) {\n      throw new ParseError('Unable to parse a private key from the given hex')\n    }\n    return new Secp256k1PrivateKey(buffer)\n  }\n\n  static newRandom () {\n    let privKey\n    do {\n      privKey = randomBytes(32)\n    } while (!secp256k1.privateKeyVerify(privKey))\n\n    return new Secp256k1PrivateKey(privKey)\n  }\n}\n\nclass Secp256k1PublicKey extends PublicKey {\n  constructor (publicKeyBytes) {\n    super()\n    this.publicKeyBytes = publicKeyBytes\n  }\n\n  getAlgorithmName () {\n    return 'secp256k1'\n  }\n\n  /**\n   * @return {Buffer} the key in bytes\n   */\n  asBytes () {\n    return Buffer.from(this.publicKeyBytes)\n  }\n\n  /**\n   * Creates a public key from a hex encode set of bytes.\n   *\n   * @param {string} publicKeyHex - the key in hex\n   * @return {PublicKey} a public key instance\n   * @throws {ParseError} if the public key is not valid\n   */\n  static fromHex (publicKeyHex) {\n    let buffer = Buffer.from(publicKeyHex, 'hex')\n    if (!secp256k1.publicKeyVerify(buffer)) {\n      throw new ParseError('Unable to parse a private key from the given hex')\n    }\n    return new Secp256k1PublicKey(buffer)\n  }\n}\n\nclass Secp256k1Context extends Context {\n  getAlgorithmName () {\n    return 'secp256k1'\n  }\n\n  verify (signature, message, publicKey) {\n    const dataHash = createHash('sha256').update(message).digest()\n    const sigBytes = Buffer.from(signature, 'hex')\n\n    return secp256k1.verify(dataHash, sigBytes, publicKey.publicKeyBytes)\n  }\n\n  sign (message, privateKey) {\n    const dataHash = createHash('sha256').update(message).digest()\n\n    const result = secp256k1.sign(dataHash, privateKey.privateKeyBytes)\n    return result.signature.toString('hex')\n  }\n\n  getPublicKey (privateKey) {\n    return new Secp256k1PublicKey(\n      secp256k1.publicKeyCreate(privateKey.privateKeyBytes)\n    )\n  }\n\n  newRandomPrivateKey () {\n    return Secp256k1PrivateKey.newRandom()\n  }\n}\n\nmodule.exports = {\n  Secp256k1PrivateKey,\n  Secp256k1PublicKey,\n  Secp256k1Context\n}\n"]},"metadata":{},"sourceType":"script"}