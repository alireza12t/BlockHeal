{"ast":null,"code":"const {\n  createHash\n} = require('crypto');\n\nconst {\n  CryptoFactory,\n  createContext\n} = require('sawtooth-sdk/signing');\n\nconst protobuf = require('sawtooth-sdk/protobuf');\n\nconst {\n  Secp256k1PrivateKey\n} = require('sawtooth-sdk/signing/secp256k1');\n\nconst pb = require('protobufjs');\n\nconst protoJson = require('../../../src/generated_protos.json');\n\nconst root = pb.Root.fromJSON(protoJson);\nconst PGPayload = root.lookup('PGPayload');\n\nconst axios = require(\"axios\");\n\nconst hash = v => {\n  return createHash('sha512').update(v).digest('hex');\n};\n\nconst FAMILY_NAME = 'blockchain98';\nconst FAMILY_VERSION = '1.0';\nconst NAMESPACE = '59b423';\n\nconst baseRequest = opts => {\n  return axios(opts);\n};\n\nconst postBinary = (endpoint, data) => {\n  return baseRequest({\n    method: 'POST',\n    url: endpoint,\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    // prevent Mithril from trying to JSON stringify the body\n    data\n  });\n};\n\nconst submit = (txn, wait = false) => {\n  return postBinary(`/blockchain/transactions${wait ? '?wait' : ''}`, txn);\n};\n\nconst getSigner = privKeyStr => {\n  const context = createContext('secp256k1');\n  var privateKey = Secp256k1PrivateKey.fromHex(privKeyStr);\n  var signer = new CryptoFactory(context).newSigner(privateKey);\n  return signer;\n};\n\nconst encodeProto = payload => {\n  const message = PGPayload.create(payload);\n  const enc = PGPayload.encode(message).finish();\n  return enc;\n};\n\nconst createTxn = (payload, signer) => {\n  const payloadBytes = encodeProto(payload);\n  const transactionHeaderBytes = protobuf.TransactionHeader.encode({\n    familyName: FAMILY_NAME,\n    familyVersion: FAMILY_VERSION,\n    inputs: [NAMESPACE],\n    outputs: [NAMESPACE],\n    signerPublicKey: signer.getPublicKey().asHex(),\n    nonce: (Math.random() * 10 ** 18).toString(36),\n    batcherPublicKey: '02065387b2ef65907896387805f363e032301de2723f61bbef7cec3be438808129',\n    //signer.getPublicKey().asHex(),\n    dependencies: [],\n    payloadSha512: hash(payloadBytes)\n  }).finish();\n  const transaction = protobuf.Transaction.create({\n    header: transactionHeaderBytes,\n    headerSignature: signer.sign(transactionHeaderBytes),\n    payload: payloadBytes\n  });\n  const transactionBytes = protobuf.TransactionList.encode({\n    transactions: [transaction]\n  }).finish();\n  return transactionBytes;\n};\n\nconst createAccount = privKeyStr => {\n  const signer = getSigner(privKeyStr);\n  const payload = {\n    action: \"CreateAccountAction\",\n    createaccount: {\n      label: 'USER'\n    }\n  };\n  const txnBytes = createTxn(payload, signer);\n  return txnBytes;\n};\n\nconst chargeAccount = (privKeyStr, amount) => {\n  const signer = getSigner(privKeyStr);\n  const payload = {\n    action: \"ChargeAccountAction\",\n    timestampClient: Number(Math.floor(Date.now() / 1000).toFixed(3)).toString(),\n    chargeaccount: {\n      amount: amount\n    }\n  };\n  const txnBytes = createTxn(payload, signer);\n  return txnBytes;\n};\n\nmodule.exports = {\n  submit,\n  hash,\n  createAccount,\n  chargeAccount\n};","map":{"version":3,"sources":["/home/amirhossein/AMHF/blockchain/blockchain98/app/src/components/transactions/transactions.js"],"names":["createHash","require","CryptoFactory","createContext","protobuf","Secp256k1PrivateKey","pb","protoJson","root","Root","fromJSON","PGPayload","lookup","axios","hash","v","update","digest","FAMILY_NAME","FAMILY_VERSION","NAMESPACE","baseRequest","opts","postBinary","endpoint","data","method","url","headers","submit","txn","wait","getSigner","privKeyStr","context","privateKey","fromHex","signer","newSigner","encodeProto","payload","message","create","enc","encode","finish","createTxn","payloadBytes","transactionHeaderBytes","TransactionHeader","familyName","familyVersion","inputs","outputs","signerPublicKey","getPublicKey","asHex","nonce","Math","random","toString","batcherPublicKey","dependencies","payloadSha512","transaction","Transaction","header","headerSignature","sign","transactionBytes","TransactionList","transactions","createAccount","action","createaccount","label","txnBytes","chargeAccount","amount","timestampClient","Number","floor","Date","now","toFixed","chargeaccount","module","exports"],"mappings":"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","sourcesContent":["const { createHash } = require('crypto')\nconst { CryptoFactory, createContext } = require('sawtooth-sdk/signing')\nconst protobuf = require('sawtooth-sdk/protobuf')\nconst { Secp256k1PrivateKey } = require('sawtooth-sdk/signing/secp256k1')\n\nconst pb = require('protobufjs')\nconst protoJson = require('../../../src/generated_protos.json')\nconst root = pb.Root.fromJSON(protoJson)\nconst PGPayload = root.lookup('PGPayload')\nconst axios = require(\"axios\");\n\nconst hash = (v) => {\n  return createHash('sha512').update(v).digest('hex')\n}\n\nconst FAMILY_NAME = 'blockchain98'\nconst FAMILY_VERSION = '1.0'\nconst NAMESPACE = '59b423'\n\nconst baseRequest = opts => {\n  return axios(opts)\n}\n\nconst postBinary = (endpoint, data) => {\n  return baseRequest({\n    method: 'POST',\n    url: endpoint,\n    headers: { 'Content-Type': 'application/json' },\n    // prevent Mithril from trying to JSON stringify the body\n    data\n  })\n}\n\nconst submit = (txn , wait = false) => {\n  return postBinary(`/blockchain/transactions${wait ? '?wait' : ''}`, txn)\n}\n\n\nconst getSigner = (privKeyStr) => {\n  const context = createContext('secp256k1');\n  var privateKey = Secp256k1PrivateKey.fromHex(privKeyStr);\n  var signer = new CryptoFactory(context).newSigner(privateKey);\n  return signer\n}\n\nconst encodeProto = (payload) => {\n  const message = PGPayload.create(payload)\n  const enc = PGPayload.encode(message).finish();\n  return enc   \n}\n\nconst createTxn = (payload, signer) => {     \n  const payloadBytes = encodeProto(payload)\n    const transactionHeaderBytes = protobuf.TransactionHeader.encode({\n      familyName: FAMILY_NAME,\n      familyVersion: FAMILY_VERSION,\n      inputs: [NAMESPACE],\n      outputs: [NAMESPACE],\n      signerPublicKey:  signer.getPublicKey().asHex(),\n      nonce: (Math.random() * 10 ** 18).toString(36),\n      batcherPublicKey: '02065387b2ef65907896387805f363e032301de2723f61bbef7cec3be438808129', //signer.getPublicKey().asHex(),\n      dependencies: [],\n      payloadSha512: hash(payloadBytes)\n    }).finish()\n    const transaction =  protobuf.Transaction.create({\n      header: transactionHeaderBytes,\n      headerSignature: signer.sign(transactionHeaderBytes),\n      payload: payloadBytes\n    })\n  const transactionBytes = protobuf.TransactionList.encode(\n    {transactions: [transaction]}\n  ).finish()\n  return transactionBytes    \n}\n\nconst createAccount = (privKeyStr) => {\n  const signer = getSigner(privKeyStr)\n  const payload = { \n    action: \"CreateAccountAction\",\n    createaccount: {\n      label: 'USER'\n    }\n  }\n  const txnBytes =  createTxn(payload, signer)\n  return txnBytes;\n}\n\nconst chargeAccount = (privKeyStr,amount) => {\n  const signer = getSigner(privKeyStr)\n  const payload = { \n    action: \"ChargeAccountAction\",\n    timestampClient: Number(Math.floor(Date.now() / 1000).toFixed(3)).toString(),\n    chargeaccount: { amount: amount }\n  }\n  const txnBytes =  createTxn(payload, signer)\n  return txnBytes;\n}\n\n\n\nmodule.exports = {\n  submit,\n  hash,\n  createAccount,\n  chargeAccount,\n}"]},"metadata":{},"sourceType":"module"}