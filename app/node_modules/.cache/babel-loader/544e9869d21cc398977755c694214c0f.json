{"ast":null,"code":"/**\n * Copyright 2017 Intel Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ------------------------------------------------------------------------------\n */\n'use strict';\n/**\n * Thrown when trying to create a context for an algorithm which does not exist.\n */\n\nclass NoSuchAlgorithmError extends Error {\n  /**\n   * Constructs a new NoSuchAlgorithmError\n   *\n   * @param {string} [message] - an optional message, defaults to the empty\n   * string\n   */\n  constructor(message = '') {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n}\n/**\n * Thrown when an error occurs during the signing process.\n */\n\n\nclass SigningError extends Error {\n  /**\n   * Constructs a new SigningError\n   *\n   * @param {string} [message] - an optional message, defaults to the empty\n   * string\n   */\n  constructor(message = '') {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n}\n/**\n * Thrown when an error occurs during deserialization of a Private or Public\n * key from various formats.\n */\n\n\nclass ParseError extends Error {\n  /**\n   * Constructs a new ParseError\n   *\n   * @param {string} [message] - an optional message, defaults to the empty\n   * string\n   */\n  constructor(message = '') {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n}\n/**\n * A private key instance.\n *\n * The underlying content is dependent on implementation.\n */\n\n\nclass PrivateKey {\n  constructor() {\n    if (this.constructor === PrivateKey) {\n      throw new TypeError('Cannot construct abstract class');\n    }\n  }\n  /**\n   * Returns the algorithm name used for this private key.\n   */\n\n\n  getAlgorithmName() {\n    throw new TypeError('Abstract method not implemented');\n  }\n  /**\n   * Return the private key encoded as a hex string\n   */\n\n\n  asHex() {\n    return this.asBytes().toString('hex');\n  }\n  /**\n   * Returns the private key bytes in a Buffer.\n   */\n\n\n  asBytes() {\n    throw new TypeError('Abstract method not implemented');\n  }\n\n}\n/**\n * A public key instance.\n *\n * The underlying content is dependent on implementation.\n */\n\n\nclass PublicKey {\n  constructor() {\n    if (this.constructor === PublicKey) {\n      throw new TypeError('Cannot construct abstract class');\n    }\n  }\n  /**\n   * Returns the algorithm name used for this public key.\n   */\n\n\n  getAlgorithmName() {\n    throw new TypeError('Abstract method not implemented');\n  }\n  /**\n   * Return the public key encoded as a hex string\n   */\n\n\n  asHex() {\n    return this.asBytes().toString('hex');\n  }\n  /**\n   * Returns the public key bytes in a Buffer.\n   */\n\n\n  asBytes() {\n    throw new TypeError('Abstract method not implemented');\n  }\n\n}\n/**\n * A context for a cryptographic signing algorithm.\n */\n\n\nclass Context {\n  constructor() {\n    if (this.constructor === Context) {\n      throw new TypeError('Cannot construct abstract class');\n    }\n  }\n  /**\n   * Returns the algorithm name used for this context.\n   */\n\n\n  getAlgorithmName() {\n    throw new TypeError('Abstract method not implemented');\n  }\n  /**\n   * Sign a message.\n   *\n   * Given a private key for this algorithm, sign the given message bytes\n   * and return a hex-encoded string of the resulting signature.\n   *\n   * @param {Buffer} message - the message bytes\n   * @param {PrivateKey} privateKey - the private key\n   *\n   * @returns {string} - The signature in a hex-encoded string\n   *\n   * @throws {SigningError} - if any error occurs during the signing process\n   */\n\n\n  sign(message, privateKey) {\n    throw new TypeError('Abstract method not implemented');\n  }\n  /**\n   * Verifies that a signature of a message was produced with the associated\n   * public key.\n   *\n   * @param {string} signature - the hex-encoded signature\n   * @param {Buffer} message - the message bytes\n   * @param {PublicKey} publicKey - the public key to use for verification\n   *\n   * @returns {boolean} - true if the public key is associated with the\n   * signature for that method, false otherwise\n   */\n\n\n  verify(signature, message, publicKey) {\n    throw new TypeError('Abstract method not implemented');\n  }\n  /**\n   * Produce a public key for the given private key.\n   *\n   * @param {PrivateKey} privateKey - a private key\n   *\n   * @return {PublicKey} - the public key for the given private key\n   */\n\n\n  getPublicKey(privateKey) {\n    throw new TypeError('Abstract method not implemented');\n  }\n  /**\n   * Generate a new random private key, based on the underlying algorithm.\n   *\n   * @return {PrivateKey} - a private key instance\n   */\n\n\n  newRandomPrivateKey() {\n    throw new TypeError('Abstract method not implemented');\n  }\n\n}\n\nmodule.exports = {\n  NoSuchAlgorithmError,\n  SigningError,\n  ParseError,\n  PublicKey,\n  PrivateKey,\n  Context\n};","map":{"version":3,"sources":["/home/amirhossein/AMHF/blockchain/blockchain98/app/node_modules/sawtooth-sdk/signing/core.js"],"names":["NoSuchAlgorithmError","Error","constructor","message","name","SigningError","ParseError","PrivateKey","TypeError","getAlgorithmName","asHex","asBytes","toString","PublicKey","Context","sign","privateKey","verify","signature","publicKey","getPublicKey","newRandomPrivateKey","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Intel Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ------------------------------------------------------------------------------\n */\n\n'use strict'\n\n/**\n * Thrown when trying to create a context for an algorithm which does not exist.\n */\nclass NoSuchAlgorithmError extends Error {\n  /**\n   * Constructs a new NoSuchAlgorithmError\n   *\n   * @param {string} [message] - an optional message, defaults to the empty\n   * string\n   */\n  constructor (message = '') {\n    super(message)\n    this.name = this.constructor.name\n  }\n}\n\n/**\n * Thrown when an error occurs during the signing process.\n */\nclass SigningError extends Error {\n  /**\n   * Constructs a new SigningError\n   *\n   * @param {string} [message] - an optional message, defaults to the empty\n   * string\n   */\n  constructor (message = '') {\n    super(message)\n    this.name = this.constructor.name\n  }\n}\n\n/**\n * Thrown when an error occurs during deserialization of a Private or Public\n * key from various formats.\n */\nclass ParseError extends Error {\n  /**\n   * Constructs a new ParseError\n   *\n   * @param {string} [message] - an optional message, defaults to the empty\n   * string\n   */\n  constructor (message = '') {\n    super(message)\n    this.name = this.constructor.name\n  }\n}\n\n/**\n * A private key instance.\n *\n * The underlying content is dependent on implementation.\n */\nclass PrivateKey {\n  constructor () {\n    if (this.constructor === PrivateKey) {\n      throw new TypeError('Cannot construct abstract class')\n    }\n  }\n\n  /**\n   * Returns the algorithm name used for this private key.\n   */\n  getAlgorithmName () {\n    throw new TypeError('Abstract method not implemented')\n  }\n\n  /**\n   * Return the private key encoded as a hex string\n   */\n  asHex () {\n    return this.asBytes().toString('hex')\n  }\n\n  /**\n   * Returns the private key bytes in a Buffer.\n   */\n  asBytes () {\n    throw new TypeError('Abstract method not implemented')\n  }\n}\n\n/**\n * A public key instance.\n *\n * The underlying content is dependent on implementation.\n */\nclass PublicKey {\n  constructor () {\n    if (this.constructor === PublicKey) {\n      throw new TypeError('Cannot construct abstract class')\n    }\n  }\n\n  /**\n   * Returns the algorithm name used for this public key.\n   */\n  getAlgorithmName () {\n    throw new TypeError('Abstract method not implemented')\n  }\n\n  /**\n   * Return the public key encoded as a hex string\n   */\n  asHex () {\n    return this.asBytes().toString('hex')\n  }\n\n  /**\n   * Returns the public key bytes in a Buffer.\n   */\n  asBytes () {\n    throw new TypeError('Abstract method not implemented')\n  }\n}\n\n/**\n * A context for a cryptographic signing algorithm.\n */\nclass Context {\n  constructor () {\n    if (this.constructor === Context) {\n      throw new TypeError('Cannot construct abstract class')\n    }\n  }\n\n  /**\n   * Returns the algorithm name used for this context.\n   */\n  getAlgorithmName () {\n    throw new TypeError('Abstract method not implemented')\n  }\n\n  /**\n   * Sign a message.\n   *\n   * Given a private key for this algorithm, sign the given message bytes\n   * and return a hex-encoded string of the resulting signature.\n   *\n   * @param {Buffer} message - the message bytes\n   * @param {PrivateKey} privateKey - the private key\n   *\n   * @returns {string} - The signature in a hex-encoded string\n   *\n   * @throws {SigningError} - if any error occurs during the signing process\n   */\n  sign (message, privateKey) {\n    throw new TypeError('Abstract method not implemented')\n  }\n\n  /**\n   * Verifies that a signature of a message was produced with the associated\n   * public key.\n   *\n   * @param {string} signature - the hex-encoded signature\n   * @param {Buffer} message - the message bytes\n   * @param {PublicKey} publicKey - the public key to use for verification\n   *\n   * @returns {boolean} - true if the public key is associated with the\n   * signature for that method, false otherwise\n   */\n  verify (signature, message, publicKey) {\n    throw new TypeError('Abstract method not implemented')\n  }\n\n  /**\n   * Produce a public key for the given private key.\n   *\n   * @param {PrivateKey} privateKey - a private key\n   *\n   * @return {PublicKey} - the public key for the given private key\n   */\n  getPublicKey (privateKey) {\n    throw new TypeError('Abstract method not implemented')\n  }\n\n  /**\n   * Generate a new random private key, based on the underlying algorithm.\n   *\n   * @return {PrivateKey} - a private key instance\n   */\n  newRandomPrivateKey () {\n    throw new TypeError('Abstract method not implemented')\n  }\n}\n\nmodule.exports = {\n  NoSuchAlgorithmError,\n  SigningError,\n  ParseError,\n  PublicKey,\n  PrivateKey,\n  Context\n}\n"]},"metadata":{},"sourceType":"script"}